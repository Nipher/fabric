#!/usr/bin/env node
/**
 * @fileOverview Filter used to format TAP report coming from browsers.
 * @name Reporter Filter
 */

var split = require('split');
var through2 = require('through2');
var once = require('once');
var faucet = require('faucet');
var PassThrough = require('stream').PassThrough;

/**
 * Empty function. Useful to initialize functions.
 */
var noop = function() {};

/**
 * Regex functional helper. Receives a regular expression and returns a new function
 * that tests a string.
 * @param {RegExp} regex
 * @returns {Function}
 */
var matchRegex = function(regex) {
  return function(str) {
    return regex.test(str);
  };
};

/** Validates if the function is the first line of the TAP report.  */
var isTAPFirstLine = matchRegex(/(.*) LOG: 'TAP (.*)'/);

/** Validates if the function is part of the TAP report.  */
var isLogLine = matchRegex(/(.*) LOG: '(.*)'/);

/**
 * Object used to capture a block of content. It receives data until that data doesn't
 * meet a defined requirement and then runs a callback with all the caught info.
 */
var sequentialStringCatcher = {
  queue: [],
  done: true,
  callbacks: {
    startRead: noop,
    reading: noop,
    end: noop,
    addSuccess: noop,
    addFailure: noop
  },

  /**
   * Add a new event handler.
   * @param {String} event Event target for handler. It can use startRead, reading, end, addSuccess or addFailure
   * @param {Function} handler Function to bind to the event.
   * @returns {sequentialStringCatcher} this instance.
   */
  on: function(event, handler) {
    if (typeof handler === 'undefined') return this;
    this.callbacks[event] = handler;
    return this;
  },

  /**
   * Add a new line to the block if the block has started and the line meets the
   * requirements specified in takeWhile function.
   * @param {String} str Line to verify.
   * @returns {boolean} True if the line was added. False otherwise.
   */
  add: function(str) {
    if (this.done && !this.callbacks.startRead(str)) {
      this.callbacks.addFailure('\n' + str);
      return false;
    }

    this.done = false;

    if (this.callbacks.reading(str)) {
      this.queue.push(str);
      this.callbacks.addSuccess();
      return true;
    }

    this.done = true;
    this.callbacks.end(this.queue.join('\n'));
    this.queue.length = 0;
    return false;
  }
};

/**
 * Set different colors and removes unnecessary info for each line in the TAP report.
 * @param {String} report Raw string.
 * @param {Function} onFormatEnd Function to be called when the formatting ends.
 * @returns {String} Properly formatted TAP report.
 */
var formatTAPReport = function(report, onFormatEnd) {
  var stream = new PassThrough();
  var faucetStream;
  var formattedReport = '\n\n';

  stream.write(report.replace(/(.*) LOG: '(.*)'/g, '$2'));
  stream.end();
  faucetStream = stream.pipe(faucet());

  faucetStream.on('data', function(chunk) {
    formattedReport += chunk;
  });

  faucetStream.on('end', function() {
    onFormatEnd(formattedReport);
  });
};

/**
 * Configures a sequentialStringCatcher the first time to capture a TAP block.
 * @param {Object} callbacks Layer object used to set the handlers for the sequentialStringCatcher
 * @param {Function} callbacks.onAddSuccess addSuccess callback.
 * @param {Function} callbacks.onAddFailure addFailure callback.
 * @param {Function} callbacks.onEnd end callback.
 * @returns {sequentialStringCatcher} Configured instance
 */
var configSequentialCatcher = once(function(callbacks) {
  return Object.create(sequentialStringCatcher)
    .on('addSuccess', callbacks.onAddSuccess)
    .on('addFailure', callbacks.onAddFailure)
    .on('startRead', isTAPFirstLine)
    .on('reading', isLogLine)
    .on('end', function(block) {
      formatTAPReport(block, callbacks.onEnd);
    });
});

/**
 * Read the lines of the stream and formats the TAP block.
 * @returns {DestroyableTransform} Though2 return object to be used in the stream line.
 */
var formatLogs = function() {
  var sequentialCatcher;

  return through2(function(chunk, enc, callback) {
    var str = chunk.toString();

    sequentialCatcher = configSequentialCatcher({
      onAddSuccess: callback.bind(this),
      onAddFailure: callback.bind(this, null),
      onEnd: callback.bind(this, null)
    });

    sequentialCatcher.add(str);
  });
};

process.stdin
  .pipe(split())
  .pipe(formatLogs())
  .pipe(process.stdout);

